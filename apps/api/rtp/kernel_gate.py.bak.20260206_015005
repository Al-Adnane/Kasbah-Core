import os
from apps.api.agents_api import load_agent

"""
Kernel Gate: The Core Orchestrator (Telemetry Enabled)
"""
from .integrity import GeometricIntegrityCalculator, BidirectionalFeedbackLoop
from .signals import SignalTracker, QIFTProcessor, HyperGraphAnalyzer
from .merkle_moat import AuditLogger
from .policy import MoEHorizonFusion, ThermodynamicProtocol
from .persona import persona_for
from apps.api.rtp.agent_state import update_state
from apps.api.rtp.geometry import geometry_score, geometry_threshold_for, geometry_penalty
from apps.api.rtp.tickets import mint_ticket, consume_ticket

class KernelGate:
    def __init__(self):
        self.integrity_calc = GeometricIntegrityCalculator()
        self.feedback_loop = BidirectionalFeedbackLoop()
        self.qift = QIFTProcessor()
        self.topology = HyperGraphAnalyzer()
        self.audit = AuditLogger()
        self.moe = MoEHorizonFusion()
        self.thermo = ThermodynamicProtocol()
        self.signal_tracker = SignalTracker()

    def decide(self, payload: dict) -> dict:
        triggered_moats = []
        tool_name = payload.get("tool_name", "unknown")
        agent_id = payload.get("agent_id", "anonymous")
        persona = persona_for(agent_id)
        
        # CRITICAL FIX: Initialize _ema here
        _ema = 0.0
        ttl_seconds = 60  # Default TTL
        ttl_factor = 1.0  # Default TTL factor
        
        # --- B: Agent allowlist (hard gate) ---
        agent_cfg = load_agent(agent_id)
        if agent_cfg:
            allowed = agent_cfg.get("allowed_tools") or []
            if allowed and tool_name and tool_name not in allowed:
                decision_str = "DENY"
                decision_kind = "DECIDE_DENY_RBAC"
                reason = "RBAC: tool not allowed for this agent"
                # still log audit for visibility
                audit_entry = self.audit.log(agent_id, tool_name, decision_str, 0.0)
                return {
                    "decision": decision_str,
                    "decision_kind": decision_kind,
                    "reason": reason,
                    "integrity_score": 0.0,
                    "threshold": None,
                    "ttl_seconds": 0,
                    "ttl_factor": 0.0,
                    "ticket": None,
                    "pre_defense_state": self.thermo.get_defense_state(),
                    "geometry_score": None,
                    "geometry_threshold": None,
                    "geometry_penalty": None,
                    "agent_state_error": None,
                    "agent_state": None,
                    "defense_state": self.thermo.get_defense_state(),
                    "audit_signature": audit_entry["signature"],
                    "merkle_root": audit_entry["current_root"][:16] + "...",
                    "moats_triggered": sorted(list(set([5,7]))),
                    "agent_id": agent_id,
                    "allowed_tools": allowed,
                }

        raw_signals = payload.get("signals", {})
        
        # Moat 3
        transformed_signals = self.qift.transform(raw_signals)
        triggered_moats.append(3)
        
        # Moat 13
        is_botnet = self.topology.log_interaction(agent_id, tool_name)
        if is_botnet:
            triggered_moats.append(13)
        
        # Moat 2
        integrity_score = self.integrity_calc.calculate(transformed_signals)
        triggered_moats.append(2)
        
        # Moat 6
        prediction_confidence = self.moe.predict(transformed_signals)
        triggered_moats.append(6)
        
        # Moat 11
        current_load = 0.6 
        pre_defense_state = self.thermo.get_defense_state()
        self.thermo.update_entropy(current_load, 1.0 - integrity_score)
        post_defense_state = self.thermo.get_defense_state()
        triggered_moats.append(11)
        
        # Moat 1
        # --- F: constraint geometry gating ---
        geom_score = geometry_score(tool_name, raw_signals)
        # geometry threshold may tighten under LOCKDOWN
        geom_thr = geometry_threshold_for(tool_name, defense_state=post_defense_state)
        geom_pen = geometry_penalty(geom_score, geom_thr)

        # --- F1: HARD GEOMETRY GATE (no read.me bypass) ---
        geometry_blocked = bool(geom_score < geom_thr)
        if geometry_blocked:
            allow = False
            reason = f"GEOMETRY_BLOCK: score {geom_score:.3f} < thr {geom_thr:.3f}"
            decision_kind = "DECIDE_DENY_GEOMETRY"

        # --- threshold computation (ordered, monotonic, persona-safe) ---
        base_thr = self.feedback_loop.get_threshold()
        try:
            base_thr = float(base_thr)
        except Exception:
            base_thr = 0.5

        # floor avoids 0.00 masking persona behavior
        base_thr = max(0.30, min(0.99, base_thr))

        # geometry penalty first
        threshold = min(0.99, max(0.0, base_thr + geom_pen))
        triggered_moats.append(1)

        # system tightening
        if post_defense_state == "LOCKDOWN":
            threshold = min(0.99, threshold + 0.20)

        # persona/agent strictness multiplier (agent DB wins)
        strict = None
        try:
            agent_cfg2 = load_agent(agent_id)
            if agent_cfg2:
                strict = float(agent_cfg2.get("integrity_bias", None))
        except Exception:
            strict = None

        if strict is None:
            try:
                strict = float(persona.integrity_bias)
            except Exception:
                strict = 1.0

        # interpret strictness: >1 stricter, <1 looser
        threshold = max(0.0, min(0.99, threshold * strict))

        allow = False
        reason = ""
        decision_kind = None

        # Persona floor
        prediction_confidence = max(prediction_confidence, float(persona.confidence_floor))

        if is_botnet:
            allow = False
            reason = "Moat 13: Suspicious topology pattern detected"
            decision_kind = "DECIDE_DENY_BOTNET"
        # Moat F1: geometry hard deny (must not be overwritten)
        elif geom_score < geom_thr:
            allow = False
            reason = f"GEOMETRY_BLOCK: score {geom_score:.3f} < thr {geom_thr:.3f}"
            decision_kind = "DECIDE_DENY_GEOMETRY"
        elif (integrity_score >= threshold or (tool_name == "read.me" and prediction_confidence > 0.9)) and prediction_confidence > 0.5:
            allow = True
            decision_kind = "DECIDE_ALLOW"
            reason = f"Integrity {integrity_score:.2f} > Threshold {threshold:.2f}"
        else:
            allow = False
            decision_kind = "DECIDE_DENY_INTEGRITY"
            reason = f"Integrity {integrity_score:.2f} < Threshold {threshold:.2f}"

        decision_str = "ALLOW" if allow else "DENY"
        if decision_kind is None:
            decision_kind = "DECIDE_ALLOW" if allow else "DECIDE_DENY"
        self.feedback_loop.update(integrity_score, decision_str)

        # Moat 5 & 7
        audit_entry = self.audit.log(agent_id, tool_name, decision_str, integrity_score)
        triggered_moats.extend([5, 7])

        # --- E: per-agent stateful risk (EMA brittleness) ---
        agent_state_error = None
        try:
            _aid = str(agent_id or "unknown")
            _sig = raw_signals if isinstance(raw_signals, dict) else {}

            _n = _sig.get("normality", _sig.get("normality_score", _sig.get("normalityScore", 1.0)))
            try:
                _n = float(_n)
            except Exception:
                _n = 1.0

            if _n < 0.0:
                _n = 0.0
            if _n > 1.0:
                _n = 1.0

            _b = 1.0 - _n
            if _b < 0.0:
                _b = 0.0
            if _b > 1.0:
                _b = 1.0

            agent_state = update_state(_aid, _b)
            try:
                # Ensure JSON-serializable
                agent_state = agent_state.__dict__ if hasattr(agent_state, '__dict__') else dict(agent_state)
            except Exception:
                agent_state = None

            # --- G: state-bound execution (EMA tightening) ---
            try:
                _ema = float((agent_state or {}).get("ema", 0.0))
            except Exception:
                _ema = 0.0

            # --- H: TTL tightening (state-bound tickets) ---
            base_ttl = 60
            ttl_factor = 1.0
            if _ema >= 0.90:
                ttl_factor = 0.10
            elif _ema >= 0.80:
                ttl_factor = 0.20
            elif _ema >= 0.60:
                ttl_factor = 0.50
            ttl_seconds = max(1, int(base_ttl * ttl_factor))

            # Raise threshold as EMA rises (soft)
            if _ema >= 0.60:
                threshold = min(0.99, threshold + 0.10)
            if _ema >= 0.80:
                threshold = min(0.99, threshold + 0.20)

            # Hard-stop for high-risk tools only (keep read.me demo-safe)
            if _ema >= 0.90 and tool_name not in ("read.me",):
                allow = False
                reason = "E+++++: EMA extreme -> deny (state-bound execution)"
                decision_kind = "DECIDE_DENY_EMA"

            # reason refresh after EMA tightening (keep logs coherent)
            if allow:
                reason = f"Integrity {integrity_score:.2f} > Threshold {threshold:.2f}"
            else:
                # if we denied for EMA, keep that message; otherwise keep integrity-vs-threshold
                if ("EMA extreme" not in (reason or "")) and ("GEOMETRY_BLOCK" not in (reason or "")) and ("Moat 13" not in (reason or "")):
                    reason = f"Integrity {integrity_score:.2f} < Threshold {threshold:.2f}"
    
    
        except Exception as e:
            agent_state = None
            agent_state_error = repr(e)
            _ema = 0.0  # FIX: Ensure _ema is defined even on exception
            # Reset TTL to defaults on exception
            ttl_seconds = 60
            ttl_factor = 1.0

        # --- H4: mint TTL-bound ticket ---
        ticket = mint_ticket(tool_name, payload.get("args", {}), ttl_seconds=ttl_seconds, agent_id=str(agent_id or "anonymous"), ema=float(_ema), geom=float(geom_score))

        return {
            "decision": decision_str,
            "decision_kind": decision_kind,
            "reason": reason,
            "integrity_score": round(integrity_score, 4),
            "threshold": round(threshold, 4),
            "ttl_seconds": ttl_seconds,
            "ttl_factor": ttl_factor,
            "ticket": ticket,
            "pre_defense_state": pre_defense_state,
            "geometry_score": geom_score,
            "geometry_threshold": geom_thr,
            "geometry_penalty": geom_pen,
            "agent_state_error": agent_state_error,
            "agent_state": agent_state,
            "defense_state": post_defense_state,
            "audit_signature": audit_entry["signature"],
            "merkle_root": audit_entry["current_root"][:16] + "...",
            "moats_triggered": sorted(list(set(triggered_moats)))
        }

    def consume(self, payload: dict) -> dict:
        """
        Consume (single-use) a previously minted ticket.
        Expected payload:
          {
            "ticket": <dict OR json-string>,
            "tool": "read.me",
            "agent_id": "smoke"   # optional, binds session when provided
          }
        Returns:
          {"valid": bool, "reason": str, "remaining_budget": None}
        """
        import json

        tool = payload.get("tool") or payload.get("tool_name") or "unknown"
        t = payload.get("ticket")

        # Accept ticket as dict or as a JSON string
        if isinstance(t, str):
            t_str = t.strip()
            # if someone accidentally sent python dict repr, try to fail clearly
            try:
                t = json.loads(t_str)
            except Exception:
                return {"valid": False, "reason": "ticket not valid JSON", "remaining_budget": None}
        if not isinstance(t, dict):
            return {"valid": False, "reason": "missing ticket", "remaining_budget": None}

        # Bind agent id when provided
        if payload.get("agent_id") is not None:
            t = dict(t)
            t["provided_agent_id"] = str(payload.get("agent_id"))

        ok, reason = consume_ticket(t, tool)
        return {"valid": bool(ok), "reason": str(reason), "remaining_budget": None}


# Singleton instance used by API routers
kernel_gate = KernelGate()
